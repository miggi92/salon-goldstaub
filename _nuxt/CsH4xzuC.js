import{u as x,av as L,aw as W,b as H,a4 as z,a8 as S,ax as U,ay as V,K as P,am as $,az as A,r as I,aA as M,ac as Q,aB as G,J as N,aC as J,aD as X,aE as R,aF as Y}from"./bArQhzGq.js";const Z={trailing:!0};function K(a,e=25,o={}){if(o={...Z,...o},!Number.isFinite(e))throw new TypeError("Expected `wait` to be a finite number");let r,s,_=[],n,t;const v=(f,h)=>(n=k(a,f,h),n.finally(()=>{if(n=null,o.trailing&&t&&!s){const m=v(f,t);return t=null,m}}),n),b=function(...f){return o.trailing&&(t=f),n||new Promise(h=>{const m=!s&&o.leading;clearTimeout(s),s=setTimeout(()=>{s=null;const c=o.leading?r:v(this,f);t=null;for(const d of _)d(c);_=[]},e),m?(r=v(this,f),h(r)):_.push(h)})},i=f=>{f&&(clearTimeout(f),s=null)};return b.isPending=()=>!!s,b.cancel=()=>{i(s),_=[],t=null},b.flush=()=>{if(i(s),!t||n)return;const f=t;return t=null,v(this,f)},b}async function k(a,e,o){return await a.apply(e,o)}const aa=Symbol.for("nuxt:client-only");function ia(...a){const e=typeof a[a.length-1]=="string"?a.pop():void 0;ea(a[0],a[1])&&a.unshift(e);let[o,r,s={}]=a,_=!1;const n=P(()=>X(o));if(typeof n.value!="string")throw new TypeError("[nuxt] [useAsyncData] key must be a string.");if(typeof r!="function")throw new TypeError("[nuxt] [useAsyncData] handler must be a function.");const t=x();s.server??=!0,s.default??=na,s.getCachedData??=B,s.lazy??=!1,s.immediate??=!0,s.deep??=L.deep,s.dedupe??="cancel",s._functionName,t._asyncData[n.value];function v(){const c={cause:"initial",dedupe:s.dedupe};return t._asyncData[n.value]?._init||(c.cachedData=s.getCachedData(n.value,t,{cause:"initial"}),t._asyncData[n.value]=T(t,n.value,r,s,c.cachedData)),()=>t._asyncData[n.value].execute(c)}const b=v(),i=t._asyncData[n.value];i._deps++;const f=s.server!==!1&&t.payload.serverRendered;{let c=function(u){const l=t._asyncData[u];l?._deps&&(l._deps--,l._deps===0&&l?._off())};const d=$();if(d&&f&&s.immediate&&!d.sp&&(d.sp=[]),d&&!d._nuxtOnBeforeMountCbs){d._nuxtOnBeforeMountCbs=[];const u=d._nuxtOnBeforeMountCbs;W(()=>{u.forEach(l=>{l()}),u.splice(0,u.length)}),H(()=>u.splice(0,u.length))}const C=d&&(d._nuxtClientOnly||z(aa,!1));f&&t.isHydrating&&(i.error.value||i.data.value!==void 0)?i.status.value=i.error.value?"error":"success":d&&(!C&&t.payload.serverRendered&&t.isHydrating||s.lazy)&&s.immediate?d._nuxtOnBeforeMountCbs.push(b):s.immediate&&i.status.value!=="success"&&b();const y=A(),D=S(n,(u,l)=>{if((u||l)&&u!==l){_=!0;const w=t._asyncData[l]?.data.value!==void 0,q=t._asyncDataPromises[l]!==void 0,O={cause:"initial",dedupe:s.dedupe};if(!t._asyncData[u]?._init){let p;l&&w?p=t._asyncData[l].data.value:(p=s.getCachedData(u,t,{cause:"initial"}),O.cachedData=p),t._asyncData[u]=T(t,u,r,s,p)}t._asyncData[u]._deps++,l&&c(l),(s.immediate||w||q)&&t._asyncData[u].execute(O),R(()=>{_=!1})}},{flush:"sync"}),g=s.watch?S(s.watch,()=>{_||(t._asyncData[n.value]?._execute.isPending()&&R(()=>{t._asyncData[n.value]?._execute.flush()}),t._asyncData[n.value]?._execute({cause:"watch",dedupe:s.dedupe}))}):()=>{};y&&U(()=>{D(),g(),c(n.value)})}const h={data:E(()=>t._asyncData[n.value]?.data),pending:E(()=>t._asyncData[n.value]?.pending),status:E(()=>t._asyncData[n.value]?.status),error:E(()=>t._asyncData[n.value]?.error),refresh:(...c)=>t._asyncData[n.value]?._init?t._asyncData[n.value].execute(...c):v()(),execute:(...c)=>h.refresh(...c),clear:()=>{const c=t._asyncData[n.value];if(c?._abortController)try{c._abortController.abort(new DOMException("AsyncData aborted by user.","AbortError"))}finally{c._abortController=void 0}j(t,n.value)}},m=Promise.resolve(t._asyncDataPromises[n.value]).then(()=>h);return Object.assign(m,h),m}function E(a){return P({get(){return a()?.value},set(e){const o=a();o&&(o.value=e)}})}function ea(a,e){return!(typeof a=="string"||typeof a=="object"&&a!==null||typeof a=="function"&&typeof e=="function")}async function ca(a){await new Promise(o=>V(o)),await x().hooks.callHookParallel("app:data:refresh",void 0)}function j(a,e){e in a.payload.data&&(a.payload.data[e]=void 0),e in a.payload._errors&&(a.payload._errors[e]=void 0),a._asyncData[e]&&(a._asyncData[e].data.value=N(a._asyncData[e]._default()),a._asyncData[e].error.value=void 0,a._asyncData[e].status.value="idle"),e in a._asyncDataPromises&&(a._asyncDataPromises[e]=void 0)}function ta(a,e){const o={};for(const r of e)o[r]=a[r];return o}function T(a,e,o,r,s){a.payload._errors[e]??=void 0;const _=r.getCachedData!==B,n=o,t=r.deep?I:M,v=s!==void 0,b=a.hook("app:data:refresh",async f=>{(!f||f.includes(e))&&await i.execute({cause:"refresh:hook"})}),i={data:t(v?s:r.default()),pending:P(()=>i.status.value==="pending"),error:J(a.payload._errors,e),status:M("idle"),execute:(...f)=>{const[h,m=void 0]=f,c=h&&m===void 0&&typeof h=="object"?h:{};if(a._asyncDataPromises[e]&&(c.dedupe??r.dedupe)==="defer")return a._asyncDataPromises[e];{const y="cachedData"in c?c.cachedData:r.getCachedData(e,a,{cause:c.cause??"refresh:manual"});if(y!==void 0)return a.payload.data[e]=i.data.value=y,i.error.value=void 0,i.status.value="success",Promise.resolve(y)}i._abortController&&i._abortController.abort(new DOMException("AsyncData request cancelled by deduplication","AbortError")),i._abortController=new AbortController,i.status.value="pending";const d=new AbortController,C=new Promise((y,D)=>{try{const g=c.timeout??r.timeout,u=sa([i._abortController?.signal,c?.signal],d.signal,g);if(u.aborted){const l=u.reason;D(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"));return}return u.addEventListener("abort",()=>{const l=u.reason;D(l instanceof Error?l:new DOMException(String(l??"Aborted"),"AbortError"))},{once:!0,signal:d.signal}),Promise.resolve(n(a,{signal:u})).then(y,D)}catch(g){D(g)}}).then(async y=>{let D=y;r.transform&&(D=await r.transform(y)),r.pick&&(D=ta(D,r.pick)),a.payload.data[e]=D,i.data.value=D,i.error.value=void 0,i.status.value="success"}).catch(y=>{if(a._asyncDataPromises[e]&&a._asyncDataPromises[e]!==C||i._abortController?.signal.aborted)return a._asyncDataPromises[e];if(typeof DOMException<"u"&&y instanceof DOMException&&y.name==="AbortError")return i.status.value="idle",a._asyncDataPromises[e];i.error.value=G(y),i.data.value=N(r.default()),i.status.value="error"}).finally(()=>{d.abort(),delete a._asyncDataPromises[e]});return a._asyncDataPromises[e]=C,a._asyncDataPromises[e]},_execute:K((...f)=>i.execute(...f),0,{leading:!0}),_default:r.default,_deps:0,_init:!0,_hash:void 0,_off:()=>{b(),a._asyncData[e]?._init&&(a._asyncData[e]._init=!1),_||Q(()=>{a._asyncData[e]?._init||(j(a,e),i.execute=()=>Promise.resolve())})}};return i}const na=()=>{},B=(a,e,o)=>{if(e.isHydrating)return e.payload.data[a];if(o.cause!=="refresh:manual"&&o.cause!=="refresh:hook")return e.static.data[a]};function sa(a,e,o){const r=a.filter(n=>!!n);if(typeof o=="number"&&o>=0){const n=AbortSignal.timeout?.(o);n&&r.push(n)}if(AbortSignal.any)return AbortSignal.any(r);const s=new AbortController;for(const n of r)if(n.aborted){const t=n.reason??new DOMException("Aborted","AbortError");try{s.abort(t)}catch{s.abort()}return s.signal}const _=()=>{const t=r.find(v=>v.aborted)?.reason??new DOMException("Aborted","AbortError");try{s.abort(t)}catch{s.abort()}};for(const n of r)n.addEventListener?.("abort",_,{once:!0,signal:e});return s.signal}const ra={content:"v3.5.0--5QWzxLrtLoXS1OgEuRjUASot_SmKOCrdrraRWWmClqk"},la={content:"_content_content",info:"_content_info"},ua={content:{type:"page",fields:{id:"string",title:"string",body:"json",description:"string",extension:"string",meta:"json",navigation:"json",path:"string",seo:"json",stem:"string"}},info:{type:"data",fields:{}}};async function F(a,e,o,r){const s=a?Y(a):{},_=`/__nuxt_content/${e}/${o}`,n={...r,headers:{...s,...r.headers},query:{v:ra[String(e)],t:void 0}};return a?await a.$fetch(_,n):await $fetch(_,n)}async function fa(a,e){return F(a,e,"sql_dump.txt",{responseType:"text",headers:{"content-type":"text/plain"}})}async function da(a,e,o){return F(a,e,"query",{headers:{"content-type":"application/json"},method:"POST",body:{sql:o}})}export{ra as a,fa as b,ua as c,da as f,ca as r,la as t,ia as u};
